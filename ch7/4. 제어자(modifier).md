# 제어자란?

제어자(modifier)는 클래스, 변수 또는 메서드의 선언분에 함께 사용되어 **_부가적읜 의미를 부여_** 한다. 제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

1. 접근 제어자
   - public, protected, default, private
   - 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.
2. 그 외
   - static
   - final
   - abstract
   - native
   - transient
   - synchronized
   - volatile
   - strictfp
   - 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

# static - 클래스의, 공통적인

static은 멤버변수, 메서드, 초기화 블럭에 사용될 수 있다.

# final - 마지막의, 변경될 수 없는

final은 클래스, 메서드, 멤버변수, 지역변수에 사용 가능하다.

1. 클래스
   - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
   - 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
2. 메서드
   - 변경될 수 없는 메서드, final로 저징된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
3. 멤버변수, 지역변수
   - 변수 없에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

### 1. 생성자를 이용한 final멤버 변수의 초기화

final이 붙은 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.

```
class Card {
    final int NUMBER;
    final String KIND;

    Card(String kind, int num) {
        KIND = kind; //매개변수로 넘겨받은 값으로 초기화한다.
        NUMBER = num;
    }
}
```

# abstract - 추상의, 미완성의

abstract는 미완성의 의미를 가지고 있다. 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.

abstract는 클래스, 메서드에 사용될 수 있다.

1. 클래스
   - 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
2. 메서드
   - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

**_추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다._**

```
abstract Class AbstractTest { //추상 클래스(추상 메서드를 포함한 클래스)
    abstract void move(); //추상 메서드(구현부가 없는 메서드)
}
```

# 접근 제어자(access modifier)

접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

접근제어자는 클래스, 멤버변수, 메서드, 생성자에 사용 가능하다.

> - private 같은 클래스 내에서만 접근이 가능하다.
> - default 같은 패키지 내에서만 접근이 가능하다.
> - protected 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
> - public 접근 제한이 전혀 없다.

### 1. 생성자의 접근 제어자

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.  
보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다.  
생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.
그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```
class Singleton {
   private Singleton() {

   }
}
```

# 제어자(modifier)의 조합

주의해야 할 사항

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
   - static 메서드는 몸통이 있는 메서드에서만 사용할 수 있기 때문이다.
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
   - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
3. abstract 메서드의 접근 제어자가 private일 수 없다.
   - abstract메서드는 자손 클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문이다.
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
   - 접근 제어자가 private인 메서드는 오버라이딩 될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.
