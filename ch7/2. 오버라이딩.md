# 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.  
상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.

# 오버라이딩의 조건

오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.

> 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
>
> - 이름이 같아야 한다.
> - 매개변수가 같아야 한다.
> - 반환타입이 같아야 한다.

한마디로 요약하면 선언부가 서로 일치해야 한다는 것이다. 다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

1. 접근 제어자는 조상 클래스의 메서드보다 넓거나 같은 범위로 변경해야 한다.
   - public > protected > (default) > private
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

# 오버로딩 vs 오버라이딩

1. 오버로딩(overloading)
   - 기존에 없는 새로운 메서드를 정의하는 것 (new)
2. 오버라이딩(overriding)
   - 상속받은 메서드의 내용을 변경하는 것(change, modify)

# super

super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.  
멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

# super() - 조상 클래스의 생성자

this()와 마찬가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.  
자손 클래스의 인스턴스를 생성하면, **_자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다._** 그래서 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다.  
이 때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.  
생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.  
**_이와 같은 조상 클래스 생성자의 호출은 상속관계를 거슬러 올라가면서 계속 반복된다._**

> Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this()또는 super(),를 호출해야 한다.  
> 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫줄에 삽입한다.
